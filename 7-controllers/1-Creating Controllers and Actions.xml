<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Creating Controllers and Actions</title>

  <para>The Controller classes are stored in the folder <link
  linkend="???">EXT:sjr_offer/Classes/Controller/</link>. The name of the
  Controller is composed by the name of the Domain Model and the Suffix
  <classname>Controller</classname>. So the Controller
  <classname>Tx_SjrOffers_Controller_OfferController</classname> is assigned
  to the Aggegate Root Object
  <classname>Tx_SjrOffers_Domain_Model_Offer</classname>. And the Name of the
  Class file is <filename>OfferController.php</filename>.</para>

  <para>The Controller class must extend the class
  <classname>Tx_Extbase_MVC_Controller_ActionController</classname> which is
  part of Extbase. The individual Actions are combined in seperate methods.
  The method names have to end in <classname>Action</classname>. The body of
  <classname>OfferController</classname> thus looks like this:</para>

  <para><code>class Tx_SjrOffers_Controller_OfferController extends
  Tx_Extbase_MVC_Controller_ActionController {</code></para>

  <para><code>// Action methods will be following here</code></para>

  <para><code>}</code></para>

  <para>When realizing the desired tasks through <emphasis>Action</emphasis>
  methods you will often stumble upon very similar flows and patterns. Each
  task will be transacted by a single <emphasis>Action</emphasis> or a chain
  of <emphasis>Actions</emphasis>:</para>

  <orderedlist>
    <listitem>
      <para>A list of Domain Objects is to be displayed.</para>
    </listitem>

    <listitem>
      <para>A single Domain Object is to be displayed.</para>
    </listitem>

    <listitem>
      <para>A new Domain Object is to be created.</para>
    </listitem>

    <listitem>
      <para>An existing Domain Object is to be edited.</para>
    </listitem>

    <listitem>
      <para>A Domain Object is to be deleted.</para>
    </listitem>
  </orderedlist>

  <para>We will shed some light on these recurring patterns in the following
  sections. Together with the schedule model you will learn the background to
  generate your own Flows.</para>

  <para><tip>
      <para>Note that you are free to choose the method names for your
      <emphasis>Actions</emphasis> as you like. Nevertheless we recommend to
      stick to the names presented here, to help other Developers to find
      their way through your Code.</para>
    </tip></para>

  <section version="5.0">
    <title>Flow Pattern "display a list of Domain Objects"</title>

    <para>The first pattern in our example fits the Action "<emphasis>display
    a list of all offers</emphasis>". One Action Method usually will be enough
    for implementing This. we choose <methodname>indexAction</methodname> as
    name of the Method:</para>

    <para><code>public function indexAction() { </code></para>

    <para><code>$offerRepository =
    t3lib_div_makeInstance('Tx_SjrOffers_Domain_Repository_OfferRepository');
    </code></para>

    <para><code>$offers = $offerRepository-&gt;findAll(); </code></para>

    <para><code>$this-&gt;view-&gt;assign('offers', $offers); </code></para>

    <para><code>return $this-&gt;view-&gt;render(); </code></para>

    <para><code>}</code></para>

    <para>This can be simplified even more. As described in chapter 4 in
    section "controlling the flow", it is not necessary to return the rendered
    content. Furthermore we avoid initializing the variable
    <methodname>$offers</methodname>, which we only use once. So we
    get:</para>

    <para><code>public function indexAction() { </code></para>

    <para><code>$offerRepository =
    t3lib_div_makeInstance('Tx_SjrOffers_Domain_Repository_OfferRepository');
    </code></para>

    <para><code>$this-&gt;view-&gt;assign('offers',
    $offerRepository-&gt;findAll()); </code></para>

    <para><code>}</code></para>

    <para>This Flow is prototypic for a task which merely has to give out
    data. Domain Objects are fetched from a Repository previously instatiated
    and passed to the View for future processing. Inside of our
    <classname>OfferController</classname> we have to make use of
    <classname>OfferRepository</classname> in the different Actions again and
    again. For that we don't have to intantiate the Repository in each and
    every Action, extbase offers the Method
    <classname>initializeAction()</classname>. It can be used for tasks
    concerning multiple Actions and is called before any Action is executed.
    In the class <classname>ActionController</classname> the body of this
    Method is empty. You can overwrite it in your own Controller though. In
    our case we assign the instance of our Repository to the Class Variable
    <classname>$offerRepository</classname>. Our Controller thus looks like
    this:</para>

    <para><code>protected $offerRepository;</code></para>

    <para><code></code></para>

    <para><code>pubilc function initializeActio() {</code></para>

    <para><code>$this-&gt;offerRepository =
    t3lib_div::makeInstance('Tx_JjrOffers_Domain_Repository_OfferRepository');</code></para>

    <para><code>}</code></para>

    <para><code></code></para>

    <para><code>public function indexAction() {</code></para>

    <para><code>$this-&gt;view-&gt;assign('offers',
    $offerRepository-&gt;findAll()); </code></para>

    <para><code>}</code></para>

    <para><classname>ActionController</classname> not only calls hte Method
    <classname>initializeAction()</classname>, which is executed before any
    Action in the Controller, but also a Method in the Form of
    <classname>initializeFooAction()</classname>, which is called only before
    the Method <classname>fooAction()</classname>. The Method for the
    initializing of Action is of course not only useful for preparing
    Repositories. You can also use them for integrating JavaScript libraries
    or to check if a specific FE user is logged in.</para>

    <para><tip>
        <para>The trick of implementing an empty Method body in the super
        class, which is the "filled" in the subclass is called
        <emphasis>Template Pattern</emphasis>.</para>
      </tip></para>
  </section>

  <section version="5.0">
    <title>Flow Pattern "display a single Domain Object"</title>

    <para>The second pattern is best put into action by a single Mehod as
    well. We call it <classname>showAction()</classname>. In contrast to
    <classname>indexAction</classname> we have to to tell this Method from
    outside which Domain Object is to be displayed. In our case th offer to be
    shown is passed to the Method as Argument:</para>

    <para><code>/**</code></para>

    <para><code> * @param Tx_SjrOffers_Domain_Model_Offer $offer The offer to
    be shown</code></para>

    <para><code> * @return string The rendered HTML string</code></para>

    <para><code> */</code></para>

    <para><code>public function showAction(Tx_SjrOffers_Domain_Model_Offer
    $offer) {</code></para>

    <para><code>$this-&gt;view-&gt;assign('offer', $offer);</code></para>

    <para><code>}</code></para>

    <para>Ususally the display of a single Object is called by a link in
    Forntend. In our example extension it connects the list view by something
    like the following URL:</para>

    <para><code>http://localhost/index.php?id=123&amp;tx_sjroffers_pi1[offer]=3&amp;tx_sjroffers_pi1[action]=show&amp;tx_sjroffers_pi1[controller]=Offer</code></para>

    <para>Due to the 2 Arguments
    <code>tx_sjroffers_pi1[controller=Offer]</code> and
    <code>tx_sjroffers_pi1[action]=show</code>, the dispatcher of extbase
    passes the request to the <classname>OfferController</classname>. In the
    request we find the information that the Action <emphasis>show
    </emphasis>is to be called. Before passing on the further processing to
    the Method <classname>showAction()</classname>, the Controller tries to
    map the Arguments received by the URL on the arguments of the Method.
    Extbase maps the arguments by their names. In our example extbase detects
    the GET Argument <classname>tx_sjroffers_pi1[offer]=3
    </classname>corresponds to the Method Argument
    <classname>$offer</classname>:
    <classname>showAction(Tx_SjrOffers_Domain_Model_Offer $offer)</classname>.
    The type of this Argument is fetched by extbase from the Method signature:
    <classname>showAction(Tx_SjrOffers_Domain_Model_Offer $offer)</classname>.
    In case this so called <emphasis>Type Hint </emphasis>should not be
    present, or (e.g. for the types <emphasis>string </emphasis>or
    <emphasis>int</emphasis> in PHP) not possible, extbase reads the type from
    the commentary written above the Method: <classname>@param
    Tx_SjrOffers_Domain_Model_Offer $offer</classname>.</para>

    <para>After successful assigning, the value of the incoming Argument has
    to be casted in the target type as well as checked for validity. (read
    more about validation in cahpter 9 in section "Validating Domain
    Objects"). In our case the incoming value is "3". Target type is the class
    <classname>Tx_SjrOffers_Domain_Model_Offer</classname>. So extbase
    interprets the the incoming value as uid of the Object to be created and
    sends a request to the <emphasis>Storage Backend</emphasis> to find an
    Object with this uid. If the Object can be reconstructed fully valid it is
    passed to the Method as argument. Inside of the Method
    <classname>showAction()</classname> the newly created Object is passed on
    to the view, which is taking care of the HTML output as usual.</para>

    <para><tip>
        <para>Inside of the Template you can access all Properties of the
        Domain Object, including all existing child objects. Thus this Flow
        Pattern does not only cover single Domain Objects but in the event
        also a complex Aggregate.</para>
      </tip>If an Argument is identified as invalid, the already implemented
    Method <classname>errorAction()</classname> of
    <classname>ActionController</classname> is called instead of the Method
    <classname>showAction()</classname>. The Method then generates a message
    for the frontend user and passes the processing to the previous Action, in
    case it is given. The latter is especially useful with invalid form field
    input as you'll see in the following.</para>
  </section>

  <section version="5.0">
    <title>Flow Pattern "creating a new Domain Object"</title>

    <para>For the third Flow Pattern, the one fpor vreating a new Domain
    Object, two steps are required: First, a form for inputting the FDomain
    Data has to be shown in Frontend. Second, a new Domain Object hast to be
    created (using the incomin form data) and put in the appropriate
    Repository. We're going to implement these two steps in the Methods
    <classname>newAction() </classname>and
    <classname>createAction()</classname>.</para>

    <para><tip>
        <para>We already described these steps in cahpter 3 in section
        "<remark>TODO: Insert correct section name</remark>." We shortly
        revise this Flow using our example extension and focus on some further
        aspects.</para>
      </tip>First the Method <classname>newAction() </classname>is called by a
    Link in frontend withe the following URL:</para>

    <para><code>http://localhost/index.php?id=123&amp;tx_sjroffers_pi1[oranization]=5&amp;tx_sjroffers_pi1[action]=new&amp;tx_sjroffers_pi1[controller]=Offer</code></para>

    <para>Extbase instantiates the <classname>Organization </classname>Object
    which is mapped to the Argument <classname>$organization, </classname>just
    as it was the case with the <classname>Offer </classname>Object in the
    Method <classname>showAction()</classname>. In the URL are no information
    (yet) though, which value the Argument <classname>$newOffer
    </classname>shall have. So the default value (=NULL) set in the Method
    signature is used. With these Arguments, the controller passes the further
    processing to the Method <classname>newAction()</classname>.</para>

    <para><code>/**</code></para>

    <para><code> * @param Tx_SjrOffers_Domain_Model_Organization $organization
    The organization</code></para>

    <para><code> * @param Tx_SjrOffers_Domain_Model_Offer $offer The new offer
    object</code></para>

    <para><code> * @return string An HTML form for creating a new
    offer</code></para>

    <para><code> * @dontvalidate $newOffer</code></para>

    <para><code> */</code></para>

    <para><code>public function
    newAction(Tx_SjrOffers_Domain_Model_Organization $organization,
    Tx_SjrOffers_Domain_Model_Offer $newOffer = NULL) {</code></para>

    <para><code>$this-&gt;view-&gt;assign('organization',$organization);</code></para>

    <para><code>$this-&gt;view-&gt;assign('newOffer',$newOffer);</code></para>

    <para><code>$this-&gt;view-&gt;assign('regions',$this-&gt;regionRepository-&gt;findAll());</code></para>

    <para><code>}</code></para>

    <para>This Action passes to the view: in
    <classname>organization</classname> the <classname>organization
    </classname>Object, in <classname>newOffer</classname> NULL (to begin
    with) the and in <classname>region </classname>all <classname>region
    </classname>Objects contained in the
    <classname>RegionRepository</classname>. The view creates the output of
    the form in frontend, using a template, which we focus on in chapter 8 in
    section "<remark>TODO: Insert correct section name</remark>". </para>
  </section>

  <section version="5.0">
    <title>with Ablaufmuster</title>

    <para>Text</para>
  </section>

  <section version="5.0">
    <title>Ablaufmuster</title>

    <para>Text</para>
  </section>
</section>
